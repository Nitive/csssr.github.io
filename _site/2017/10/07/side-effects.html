<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Осторожно! Возможны побочные эффекты &#8211; CSSSR</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Разбираемся с тем, что такое сайд-эффекты и что они несут нашему коду">
	<meta name="author" content="CSSSR">
	<meta name="keywords" content="post">
	<link rel="canonical" href="/2017/10/07/side-effects">

	<!-- Custom CSS -->
	<link rel="stylesheet" href="/css/main.css" type="text/css">

	<!-- Open Graph -->
	<!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
	<meta property="og:locale" content="ru_RU">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Осторожно! Возможны побочные эффекты">
	<meta property="og:description" content="Разбираемся с тем, что такое сайд-эффекты и что они несут нашему коду">
	<meta property="og:url" content="/2017/10/07/side-effects">
	<meta property="og:site_name" content="CSSSR">
	

	<!-- Icons -->
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<link sizes="57x57" href="/apple-touch-icon-57x57.png" rel="apple-touch-icon">
	<link sizes="114x114" href="/apple-touch-icon-114x114.png" rel="apple-touch-icon">
	<link sizes="72x72" href="/apple-touch-icon-72x72.png" rel="apple-touch-icon">
	<link sizes="144x144" href="/apple-touch-icon-144x144.png" rel="apple-touch-icon">
	<link sizes="60x60" href="/apple-touch-icon-60x60.png" rel="apple-touch-icon">
	<link sizes="120x120" href="/apple-touch-icon-120x120.png" rel="apple-touch-icon">
	<link sizes="76x76" href="/apple-touch-icon-76x76.png" rel="apple-touch-icon">
	<link sizes="152x152" href="/apple-touch-icon-152x152.png" rel="apple-touch-icon">
	<link sizes="180x180" href="/apple-touch-icon-180x180.png" rel="apple-touch-icon">
	<link sizes="192x192" href="/favicon-192x192.png" rel="icon" type="image/png">
	<link sizes="160x160" href="/favicon-160x160.png" rel="icon" type="image/png">
	<link sizes="96x96" href="/favicon-96x96.png" rel="icon" type="image/png">
	<link sizes="16x16" href="/favicon-16x16.png" rel="icon" type="image/png">
	<link sizes="32x32" href="/favicon-32x32.png" rel="icon" type="image/png">
	<meta name="application-name" content="Осторожно! Возможны побочные эффекты">
	<meta name="msapplication-tooltip" content="Разбираемся с тем, что такое сайд-эффекты и что они несут нашему коду">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="/mstile-large.png">
	<meta name="msapplication-starturl" content="/2017/10/07/side-effects">
	<meta name="msapplication-tap-highlight" content="no">
	<meta name="msapplication-square70x70logo" content="/mstile-small.png">
	<meta name="msapplication-square150x150logo" content="/mstile-medium.png">
	<meta name="msapplication-wide310x150logo" content="/mstile-wide.png">
	<meta name="msapplication-square310x310logo" content="/mstile-large.png">
</head>

<body class="">
	<div class="site-wrap">
		<header class="site-header px2 px-responsive">
	<div class="wrap">
		<nav class="header measure">
			<a href="/" class="site-title" aria-label="CSSSR"></a>
			<div class="header-links">
				<a href="/" class="header-link ">Статьи</a>
				<a href="/cgc" class="header-link ">CGC</a>
			</div>
			
				<div class="social-icons">
	<div class="left">
		
			<a class="icon icon_github" href="https://github.com/CSSSR" aria-label="GitHub"></a>
		
		<a class="icon icon_rss" href="/feed.xml" aria-label="RSS"></a>
		
			<a class="icon icon_twitter" href="https://twitter.com/csssr_dev" aria-label="Twitter"></a>
		
		
			<a class="icon icon_envelope" href="mailto:hr@csssr.io" aria-label="Напишите нам"></a>
		
	</div>
</div>

			
		</nav>
	</div>
	<div class="clearfix"></div>
</header>


		<div class="post p2 p-responsive wrap" role="main">
			<div class="measure">
				


<div class="post-header mb2">
	<h1>Осторожно! Возможны побочные эффекты</h1>
	<span class="post-meta">
		Oct 7, 2017
		
			by <a target="_blank" class="post-author" rel="author" href="https://twitter.com/bracketsarrows">bracketsarrows</a>
		
	</span><br>
	
	<span class="post-meta small">30 minute read</span>
</div>

<article class="post-content">
	<blockquote>
  <p>Начинать нужно с того, что сеет сомнение.</p>

  <p>– <cite>Братья Стругацкие</cite></p>
</blockquote>

<h2 id="типичный-фронтенд">Типичный фронтенд</h2>

<p>Давайте посмотрим на простой пример фронтенд-кода:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">URL</span> <span class="o">=</span> <span class="s1">'https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&amp;tag=cats'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">app</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
    <span class="s1">'click'</span><span class="p">,</span>
    <span class="p">()</span> <span class="o">=&gt;</span> 
      <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">tagName</span> <span class="o">===</span> <span class="s1">'BUTTON'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fetch</span><span class="p">(</span><span class="nx">URL</span><span class="p">)</span>
          <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">().</span><span class="nx">data</span><span class="p">.</span><span class="nx">image_url</span><span class="p">)</span>
          <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">gifSrc</span> <span class="o">=&gt;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'img'</span><span class="p">).</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s1">'src'</span><span class="p">,</span> <span class="nx">gifSrc</span><span class="p">))</span>
      <span class="p">}</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Что является результатом работы этой функции?</p>

<ul>
  <li>функция делает HTTP запрос при помощи <code class="highlighter-rouge">fetch</code>;</li>
  <li>функция устанавливает атрибут <code class="highlighter-rouge">src</code> тегу <code class="highlighter-rouge">img</code> при помощи <code class="highlighter-rouge">.setAttribute</code>.</li>
</ul>

<p>От чего зависит эта функция?</p>

<ul>
  <li>функция зависит от событий, полученных из <code class="highlighter-rouge">document.addEventListener</code>;</li>
  <li>функция зависит от результата HTTP запроса, полученного из <code class="highlighter-rouge">fetch</code>.</li>
</ul>

<p>Теперь давайте скроем реализацию функции и ещё раз посмотрим на неё:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">app</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Хм, теперь кажется, что функция ни от чего не зависит и вообще ничего не делает. В целом всё логично — не видя реализации функции, мы не можем определить её действие. Давайте посмотрим на другую функцию:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И скроем её реализацию:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>В этом случае мы видим и от чего зависит функция, и что возвращает: она явно что-то делает и возвращает результат, вычисленный от переданного ей <code class="highlighter-rouge">list</code>.</p>

<p>Почему так? В чем разница между <code class="highlighter-rouge">app</code> и <code class="highlighter-rouge">sum</code>? Что это за два разных вида функций?</p>

<h2 id="два-вида-функций">Два вида функций</h2>

<p><code class="highlighter-rouge">sum</code> берёт зависимые значения <em>только</em> из списка аргументов и возвращает результат <em>только</em> при помощи оператора <code class="highlighter-rouge">return</code> — то есть взаимодействует с окружающим кодом <em>только</em> через стандартные механизмы вызова функции.</p>

<p>Такие функции называются чистыми (pure).</p>

<p><code class="highlighter-rouge">app</code> же, наоборот, в качестве аргументов использует данные, которые попадают в неё неявно (не через список аргументов), и возвращает результат своей работы неявно (не через <code class="highlighter-rouge">return</code>).</p>

<p>Про такие функции говорят, что они обладают <em>сайд-эффектами</em>, и в противоположность чистым функциям их называют грязными.</p>

<p>То есть:</p>

<blockquote>
  <p>Cайд-эффектами называют неявные зависимости функции или неявные результаты её работы.</p>
</blockquote>

<p>Звучит довольно просто, однако на практике в языках без явных ограничений на чистоту функции <a href="http://staltz.com/is-your-javascript-function-actually-pure.html">данное определение предстаёт не таким однозначным</a>.</p>

<p>Чтобы избежать софистики, давайте вместо попытки дать определение сайд-эффектам попробуем выделить их ключевые свойства. То, что будет удовлетворять этим свойствам, мы и будем считать сайд-эффектом.</p>

<h2 id="сайд-эффект--что-ты-такое">Сайд-эффект — что ты такое?</h2>

<p>Первое и самое главное:</p>

<h4 id="сайд-эффект--это-не-первоклассный-обьект">Сайд-эффект — это не первоклассный обьект</h4>

<p>Что это значит? <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">Первоклассный объект (first-class object)</a> — это сущность в языке программирования, которую:</p>

<ul>
  <li>можно сохранить в переменной или структурах данных;</li>
  <li>можно передать в функцию как аргумент;</li>
  <li>можно вернуть из функции как результат.</li>
</ul>

<p>Проще говоря, первоклассный объект можно легко представить в виде некоторого <em>значения</em>.
Очевидно, что для сайд-эффектов это не так. Мы не можем просто взять и переписать функцию <code class="highlighter-rouge">app</code> в виде:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">app</span><span class="p">(</span><span class="nx">httpResponse</span><span class="p">,</span> <span class="nx">domEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span> <span class="nx">our</span> <span class="nx">logic</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">httpRequest</span><span class="p">,</span> <span class="nx">domMutation</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p><img src="/images/side-effects/no-first-class.jpg" alt="No first class" /></p>

<h4 id="сайд-эффекты-зависят-отвлияют-на-внешнее-окружение">Сайд-эффекты зависят от/влияют на внешнее окружение</h4>

<p>Это довольно очевидное свойство. Для того, чтобы корректно выполнить некоторый сайд-эффект, нам необходимо корректное окружение: для HTTP запроса нужна рабочая сеть, для запроса к DOM необходим сформированный DOM и так далее.</p>

<h4 id="сайд-эффекты-лишают-функции-ссылочной-прозрачности">Сайд-эффекты лишают функции ссылочной прозрачности</h4>

<p>Ссылочная прозрачность (referential transparency) — свойство функции, благодаря которому можно всегда и везде вместо результата работы функции подставить её вызов.</p>

<p>То есть вместо <code class="highlighter-rouge">var result = sum(list); return [result, result];</code> можно спокойно написать <code class="highlighter-rouge">return [sum(list), sum(list)];</code>.</p>

<p>Функции с сайд-эффектами не обладают этим свойством — вызвав <code class="highlighter-rouge">app</code> два раза, мы получим совершенно другие результаты (будет два listener вместо одного, два HTTP запроса при клике вместо одного и так далее).</p>

<h4 id="сайд-эффекты-изменяют-свойства-кода-в-котором-используются-до-самой-вершины-стека-вызовов">Сайд-эффекты изменяют свойства кода, в котором используются, до самой вершины стека вызовов</h4>

<p>Функция с сайд-эффектом внутри сама становится в некотором смысле сайд-эффектом. Что такое <code class="highlighter-rouge">fetch</code>? Это функция, которая внутри себя содержит сайд-эффекты, или это целиком сайд-эффект? А если завернуть её в дополнительную обёртку? Для нас важно то, что использование сайд-эффектов внутри других функций приводит к приобретению этими функциями всех свойств сайд-эффектов.</p>

<p>На самом деле, скорее всего, последние два свойства вытекают из первого — но это только догадка, и поэтому я решил вынести их в отдельные пункты.</p>

<h2 id="что-всё-это-значит-для-нас">Что всё это значит для нас?</h2>

<p>Ну, окей, сайд-эффекты имеют какие-то свои специфичные свойства. Но что эти свойства означают для нас на практике?</p>

<h4 id="код-с-сайд-эффектами-сложен-для-анализа-как-человеком-так-и-машиной">Код с сайд-эффектами сложен для анализа (как человеком, так и машиной)</h4>

<p>Для начала давайте посмотрим на код без сайд-эффектов — все функции в нём чистые.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcAnything</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">calcA</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">calcB</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="k">return</span> <span class="err">с</span><span class="nx">alcC</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Мы можем легко увидеть, какие значения от каких зависят, а какие не играют роли. К примеру, мы видим, что от <code class="highlighter-rouge">a</code> ничего не зависит и его вычисление можно смело удалить.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcAnything</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="err">с</span><span class="nx">alcC</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">calcB</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Более того, мы можем построить граф вычислений:</p>

<p><img src="/images/side-effects/analyze.svg" alt="Scheme of control flow" /></p>

<p>А теперь попробуем проделать то же самое с кодом, в котором, <em>возможно</em>, содержатся сайд-эффекты:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">doSomethingA</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">doSomethingB</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">doSomethingC</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Мы всё ещё можем сказать, что, к примеру, <code class="highlighter-rouge">b</code> зависит от <code class="highlighter-rouge">value</code>, но мы не можем со всей уверенностью утверждать, что <code class="highlighter-rouge">b</code> не зависит от вычисления <code class="highlighter-rouge">a</code>. Представьте, что <code class="highlighter-rouge">doSomethingA</code> записывает что-то в файл, из которого затем читает <code class="highlighter-rouge">doSomethingB</code>. Соответственно, в коде с сайд-эффектами любое вычисление потенциально может зависеть от любого, так как все они влияют на один и тот же внешний мир.</p>

<p>Это оказывает влияние на:</p>

<ul>
  <li>машинный анализ (IDE не сможет подсказать нам, правильно ли мы используем ту или иную функцию);</li>
  <li>анализ человеком (зачастую код-ревью просто не работает, потому что правки кода в одном месте влияют на другую часть системы).</li>
</ul>

<p>Также в случае кода с сайд-эффектами значительно усложняется рефакторинг. К примеру, удаление неиспользующегося кода:</p>

<p><img src="/images/side-effects/complicate-refactoring.gif" alt="Delete unused code" /></p>

<h4 id="код-с-сайд-эффектами-сложно-переиспользовать">Код с сайд-эффектами сложно переиспользовать</h4>

<p>Это менее очевидное следствие из свойств сайд-эффектов. Давайте вновь взглянем на код, состоящий из чистых функций.</p>

<p>Мы написали функцию, которая считает длину и сумму массива:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcLengthAndSum</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>
<p>Используя её, мы можем легко написать функцию, вычисляющую только длину списка:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcLength</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">calcLengthAndSum</span><span class="p">(</span><span class="nx">list</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Или его среднее:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcMean</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">calcLengthAndSum</span><span class="p">(</span><span class="nx">list</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">sum</span> <span class="o">/</span> <span class="nx">res</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Чистые функции крайне легко переиспользуются: даже если они делают что-то лишнее или что-то немного не так, мы всегда можем исправить это, просто добавив обёртку из ещё одной чистой функции.</p>

<p>Как говорится:</p>

<blockquote>
  <p>Любую проблему можно решить путём введения дополнительного уровня абстракции, кроме проблемы слишком большого количества уровней абстракции.</p>

</blockquote>

<p>Давайте посмотрим на функцию с сайд-эффектами, которая делает HTTP запрос и записывает результат в некий файл:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sendRequestAndWriteFile</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>Теперь где-то в коде нам понадобилось отправлять тот же запрос, но не записывать его в файл.</p>

<p>Cкорее всего, мы добавим специальную опцию в <code class="highlighter-rouge">sendRequestAndWriteFile</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sendRequest</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sendRequestAndWriteFile</span><span class="p">({</span>
    <span class="na">onlyRequest</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>То же самое для ситуации, когда нам захотелось отправлять запросы на другой URL:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sendRequestAndWriteFileOnUrl</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">sendRequestAndWriteFile</span><span class="p">({</span> <span class="na">url</span><span class="p">:</span> <span class="nx">url</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Так как сайд-эффект — это <em>неявный</em> результат, мы не можем повлиять на него за пределами места его создания — отбросить его часть или как-то преобразовать, как в случае с результатом <code class="highlighter-rouge">calcLengthAndSum</code>.</p>

<p><img src="/images/side-effects/compose-pure-vs-dirty.svg" alt="Compose pure vs dirty" /></p>

<p>Это заставляет нас вместо простого переиспользования добавлять множество опций в функцию, что очень сильно увеличивает <a href="https://ru.wikipedia.org/wiki/Цикломатическая_сложность">цикломатическую сложность</a> кода a.k.a <a href="http://eslint.org/docs/rules/complexity">complexity</a>.</p>

<p>Количество вариантов выполнения растёт со скоростью 2^n: для функции всего с двумя булевыми опциями мы получаем уже 4 варианта исполнения, для трёх опций — уже 8 и так далее.</p>

<h4 id="cайд-эффекты-сложно-тестировать">Cайд-эффекты сложно тестировать</h4>

<p>С этим наверняка знакомы все. Сравните:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">it</span><span class="p">(</span><span class="s1">'2 + 2 = 4'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></div>

<p>с:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">it</span><span class="p">(</span><span class="s1">'remoteAdd send args to endpoint'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">fakeRes</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">mock</span><span class="p">(</span><span class="nx">HttpClient</span><span class="p">,</span> <span class="p">{</span><span class="na">post</span><span class="p">:</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fakeRes</span><span class="p">;</span>
  <span class="p">}})</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">remoteAdd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">fakeRes</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Выглядит немного сложнее, да? Но постойте, мы не проверили тот факт, что наша функция делает ровно один <code class="highlighter-rouge">HTTP</code> запрос. Исправим:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code>it('remoteAdd send args to endpoint', () =&gt; {
<span class="gi">+ var postCalls = [];
</span>  var fakeRes = {};
  mock(HttpClient, {post: (...args) =&gt; {
<span class="gi">+   postCalls.push(args);
</span>    return fakeRes;
  }})
  var result = remoteAdd(2, 2);
<span class="gi">+ expect(postCalls.length).toBe(1);
+ expect(postCalls[0]).toEqual({url: URL, params: {a: 2, b: 2}});
</span>  expect(result).toBe(fakeRes);
});
</code></pre></div></div>

<p>Зачем мы вообще пишем автоматизированные тесты? Для того, чтобы контролировать <em>изменения</em> кодовой базы. В случае изменения поведения кода мы сразу увидим, что старые тесты не пройдут. Дело в том, что при достаточно большой кодовой базе различные изменения могут конфликтовать между собой и «ломать» друг друга. Автоматические тесты защищают наши изменения от случайной поломки при каких-либо правках (это может быть банальный мерж конфликтов).</p>

<p>Давайте изменим тестируемые функции и посмотрим, что произойдёт в обоих случаях:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function add(a, b) {
<span class="gd">- return a + b;
</span><span class="gi">+ return {result: a + b};
</span>}
</code></pre></div></div>

<p>Тест, конечно же, упадёт — <code class="highlighter-rouge">4</code> не равно <code class="highlighter-rouge">{result: 4}</code>.</p>

<p>Теперь давайте изменим <code class="highlighter-rouge">remoteAdd</code>:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function remoteAdd(a, b) {
<span class="gi">+ writeFile('log', [a, b]);
</span>  return HttpClient.post(a, b);
}
</code></pre></div></div>
<p>Результат работы функции изменился — теперь она ещё и пишет в файл. Однако наш тест совершенно этого не заметил и продолжает проходить как ни в чём не бывало.</p>

<p><img src="/images/side-effects/bad-tests.png" alt="My tests is passed" /></p>

<p>Так как функции с сайд-эффектами зависят от внешнего мира и влияют на него неявно, то, соотвественно, чтобы корректно протестировать такую функцию, необходимо:</p>

<ul>
  <li>полностью смоделировать <em>весь</em> окружающий мир (сетевые запросы, состояние <code class="highlighter-rouge">DOM</code>, состояние файловой системы) в виде некоторого <em>значения</em> до вызова функции;</li>
  <li>вызвать функцию;</li>
  <li>проверить состояние значения, моделирующего <em>весь</em> внешний мир.</li>
</ul>

<p>Очевидно, что сделать это полностью корректно, скорее всего, <em>невозможно</em>, так как количество типов сайд-эффектов в <code class="highlighter-rouge">JS</code> не ограничено.</p>

<p>Ситуацию может немного исправить соглашение, что все зависимости, которые могут исполнять сайд-эффекты, должны явно передаваться в функцию, то есть:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-function remoteAdd(a, b) {
</span><span class="gi">+function remoteAdd(a, b, HttpClient) {
</span>  return HttpClient.post(a, b);
}
</code></pre></div></div>

<p>Добавим <code class="highlighter-rouge">writeFile</code>:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-function remoteAdd(a, b, HttpClient) {
</span><span class="gi">+function remoteAdd(a, b, HttpClient, writeFile) {
+ writeFile('log', [a, b]);
</span>  return HttpClient.post(a, b);
}
</code></pre></div></div>

<p>Наш тест упадёт с <code class="highlighter-rouge">undefined is not function</code>, так как мы не передали <code class="highlighter-rouge">writeFile</code>. Отлично!</p>

<p>Какие проблемы у подобного подхода:</p>

<ul>
  <li>мы не можем точно определить, какие зависимости делают сайд-эффект, а какие нет. Поэтому мы будем передавать абсолютно <em>все</em> зависимости таким образом. Очевидно, что делать это самостоятельно невозможно, поэтому нам понадобится <a href="https://docs.angularjs.org/guide/module#!">специальная система модулей</a>. Данный подход получил название Dependency Injection.</li>
  <li>даже с такой системой мы всё ещё можем написать плохой мок в тестах — к примеру, полениться проверить вызов метода <code class="highlighter-rouge">.put</code> у <code class="highlighter-rouge">HttpClient</code>. Да, мы сделали описание зависимости от внешнего мира более явным. Но у нас всё ещё нет стандартного способа сравнить состояние мира до и после, как мы можем сделать это с данными при помощи стандартной операции глубокого сравнения. Эту операцию мы будем вынуждены писать заново каждый раз для каждой зависимости и, скорее всего, для каждого теста. И рано или поздно мы, вероятней всего, где-нибудь допустим ошибку.</li>
</ul>

<p>Если бы мы хотели протестировать код с сайд-эффектами «честно», мы должны были написать что-то подобное:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// некий объект, отслеживающий состояние внешнего мира</span>
<span class="kd">var</span> <span class="nx">world</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">World</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">remoteAdd</span><span class="p">(</span><span class="nx">world</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">output</span><span class="p">)</span>
<span class="c1">// все изменения внешнего мира с момента создания объекта</span>
<span class="nx">expect</span><span class="p">(</span><span class="nx">world</span><span class="p">.</span><span class="nx">changes</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">sideEffects</span><span class="p">)</span>
</code></pre></div></div>

<p>Тогда бы мы получили возможность сверять выполненные сайд-эффекты в функции с ожидаемыми при помощи стандартного <code class="highlighter-rouge">.toEqual</code> (обычного глубокого сравнения объектов). Простая передача зависимостей через аргументы (и DI как её следствие) не даёт нам такой возможности — это половинчатое решение. С одной стороны, оно не решает проблему тестирования до конца, с другой — вносит определённое усложнение в наш код: к статической системе модулей добавляется ещё одна, динамическая. Так случилось потому, что вместо устранения причины проблемы (наличия сайд-эффектов) мы пытались исправить лишь её последствия (сложности тестирования).</p>

<p><a href="http://rea.tech/to-kill-a-mockingtest/">Более подробная статья, почему моки — это сложно</a></p>

<p>Альтернативным способом решения проблемы является написание полностью интеграционных тестов с полноценным браузерным или серверным окружением. Помимо всё тех же проблем со сложностью создания и сравнения состояния окружения (к примеру, как сравнить весь <code class="highlighter-rouge">DOM</code> до некоторой операции и после?) добавляются ещё и следующие проблемы:</p>

<ul>
  <li>подобные тесты медленно запускаются, долго работают, тратят кучу электричества, работают ненадёжно;</li>
  <li>нет возможности хоть как-то локализовать проблему: можно понять, что что-то не работает, но нельзя понять, почему.</li>
</ul>

<h4 id="cайд-эффекты-непредсказуемы-и-не-воспроизводимы">Cайд-эффекты непредсказуемы и не воспроизводимы</h4>

<blockquote>
  <p>Всё течёт, всё меняется, никто не может дважды войти в один и тот же поток, и к смертной сущности никто не прикоснется дважды!</p>

  <p>– <cite>Гераклит</cite></p>
</blockquote>

<p>Станете ли вы заворачивать вызов <code class="highlighter-rouge">add(2, 2)</code> в блок <code class="highlighter-rouge">try/catch</code>? Думаю, нет — в этом нет смысла.
А <code class="highlighter-rouge">divide(a, b)</code>? Да, конечно — при <code class="highlighter-rouge">b === 0</code> произойдет ошибка.</p>

<p>Может ли произойти ошибка при вызове <code class="highlighter-rouge">remoteAdd(2, 2)</code>, и если да, то при каких входных параметрах? Да, может, при любых параметрах. А может и не произойти. Мы не знаем и никак не можем повлиять на это. Внешний мир непредсказуем, он может сломаться в любой момент: браузер может упасть, сеть может погаснуть, а сервер — сгореть.</p>

<p>Из-за того, что внешний мир непредсказуем и постоянно изменяется, мы также не можем воспроизвести результаты вычислений, содержащих сайд-эффекты.</p>

<p><code class="highlighter-rouge">add(a, b) === add(a, b)</code> будет всегда истинно в любых условиях и окружении. Мы можем легко воспроизвести результаты некоторой проблемы с продакшена, просто взяв, к примеру, входные данные с мониторинга и запустив вычисления с этими параметрами. Сайд-эффекты приводят к невоспроизводимым багам: чтобы понять, в чём была проблема, нам надо проанализировать не только наш код, но и состояние всего окружающего мира в тот момент. Это намного более трудоёмко, а порой и вообще невозможно.</p>

<h4 id="cайд-эффекты-не-типизируются">Cайд-эффекты не типизируются</h4>

<p><img src="/images/side-effects/undefined-is-not-function.jpg" alt="Undefined is not a function" /></p>

<p>Одним из способов контроля кодовой базы и доказательства отсутствия нежелательного поведения программы является статическая типизация.</p>

<p>Очень много копий сломано вокруг того, <a href="https://habrahabr.ru/post/192108/">нужна ли она вообще</a> или <a href="https://medium.com/javascript-scene/the-shocking-secret-about-static-types-514d39bf30a3#.kzfrsyeim">нет</a>.</p>

<p>Моё мнение простое: статическая типизация — это инструмент, незаменимый для написания некоторого типа ПО — такого, где очень много кода, много программистов, много связанных подсистем.</p>

<p>Однако вопрос не в этом, а в том, как на использование типизации влияют сайд-эффекты. Рассмотрим пример: предположим, мы имеем функцию, которая по описанию изменения как-то модифицирует <code class="highlighter-rouge">DOM</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">patchDOM</span><span class="p">(</span><span class="nx">patch</span><span class="p">:</span> <span class="nx">DOMPatch</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>Неявно эта функция зависит от существования <code class="highlighter-rouge">DOM</code>. И её результатом является его изменение. Однако мы никак не можем описать эту информацию в типах — ни о неявной зависимости от <code class="highlighter-rouge">DOM</code>, ни о том, что её результатом будет его изменение. В результате, если мы случайно применим эту функцию в окружении без DOM, то получим ошибку при исполнении:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">serverProgram</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">patchDOM</span><span class="p">(</span><span class="nx">patch</span><span class="p">);</span> <span class="c1">// run-time error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Сайд-эффекты за счет своей неявности не поддаются описанию типами, и тайп-чекер не может помочь найти проблемы с ними.</p>

<p>Возможным решением является использование <a href="https://medium.com/@gcanti/higher-kinded-types-in-flow-275b657992b7#.430oe011t">имитации Higher-Kinded types</a> для реализации <a href="https://medium.com/@gcanti/the-eff-monad-implemented-in-flow-40803670c3eb#.521yqwoyu">типа <code class="highlighter-rouge">Eff</code></a> при помощи <code class="highlighter-rouge">Flow</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">DOM</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="s1">'DOM'</span> <span class="p">};</span>
<span class="kd">function</span> <span class="nx">patchDOM</span><span class="p">(</span><span class="nx">patch</span><span class="p">:</span> <span class="nx">DOMPatch</span><span class="p">):</span> <span class="nx">Eff</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">write</span><span class="p">:</span> <span class="nx">DOM</span> <span class="p">},</span> <span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>И, соотвественно, <code class="highlighter-rouge">serverProgram</code> просто не скомпилируется, если у неё в типе не будет указан <code class="highlighter-rouge">Eff</code> типа <code class="highlighter-rouge">{ write: DOM }</code>, а внутри неё будет использоваться <code class="highlighter-rouge">patchDOM</code>.</p>

<p>Однако:</p>

<ul>
  <li>этот способ полагается на не самые очевидные механизмы <code class="highlighter-rouge">Flow</code> и довольно сложен для понимания;</li>
  <li>он не поможет в случае наличия сайд-эффектов в коллбэках или других местах, из которых нельзя <em>вернуть</em> результат;</li>
  <li>такие типы не будут выведены для javascript API (<code class="highlighter-rouge">console</code>, <code class="highlighter-rouge">XMLHttpRequest</code> и так далее).</li>
</ul>

<p>В общем, решение не общее и не самое простое.</p>

<h4 id="усложнение-интерактивной-разработки-кода-с-сайд-эффектами">Усложнение интерактивной разработки кода с сайд-эффектами</h4>

<p>Интерактивная разработка начинает набирать популярность. Практически все более-менее популярные языки имеют в стандартной поставке <a href="https://ru.wikipedia.org/wiki/REPL">REPL</a> (отдельно или в составе дебаггера). Современные браузеры вообще позволяют <a href="http://www.hongkiat.com/blog/google-chrome-workspace/">писать код прямо в них</a>.</p>

<p>Появляются и отдельные IDE, нацеленные именно на интерактивную разработку. К примеру, <a href="http://lighttable.com">Light table</a>, позволяющая в реальном времени следить за результатами вычислений:</p>

<p><img src="/images/side-effects/watches.png" alt="Light Table" /></p>

<p><a href="http://tonsky.me/blog/interactive-development/">Отличная статья о том, почему интерактивная разработка — это прекрасно!</a></p>

<p>Давайте посмотрим, какие коррективы вносят сайд-эффекты в подобную практику. Допустим, мы разрабатываем функцию, осуществляющую запрос на удаление некоторого юзера — <code class="highlighter-rouge">deleteUser</code>. Очевидно, что мы не сможем запустить эту функцию несколько раз для одного и того же юзера, чтобы проверить её работу в REPL. Более того, для проверки результатов её работы нам понадобится каждый раз смотреть текущее состояние сервера.</p>

<p>Главное преимущество интерактивной разработки — быстрая ответная реакция от только что написанного кода — в таком случае сводится на нет тем, что нам необходимо постоянно наблюдать состояние окружающего мира и периодически исправлять его. Например, восстанавливать удалённого юзера.</p>

<p>Возможным решением здесь будет REPL, интегрированный в тестовый фреймворк: <code class="highlighter-rouge">jest-repl</code>, <code class="highlighter-rouge">mocha debug repl</code> со встроенной возможностью устанавливать моки для определённых сайд-эффектов.</p>

<h4 id="для-кода-с-сайд-эффектами-сложно-применить-тестирование-основанное-на-проверке-свойств">Для кода с сайд-эффектами сложно применить тестирование, основанное на проверке свойств</h4>

<p>Тестирование, основанное на проверке свойств, или генеративное тестирование, или property-based тестирование — техника, позволяющая описывать свойства какой-то программной сущности (функции, к примеру) и проверять её при помощи генерации входных параметров.</p>

<p>Это очень мощная техника, которая позволяет доказать (с некоторой долей вероятности, конечно же) некоторые утверждения о программном коде. Она становится особенно важной в языках без сильной статической системы типов.</p>

<p>Но, как я отметил в <a href="http://blog.csssr.ru/2017/04/25/property-testing/">предыдущей своей статье</a>, крайне сложно определить какое-либо свойство для кода с сайд-эффектами — за счет их непредсказуемости.</p>

<h2 id="мелкие-вредители-вредящие-по-крупному">Мелкие вредители, вредящие по-крупному</h2>

<p><img src="/images/side-effects/gremlins.png" alt="Gremlin" /></p>

<p>Сайд-эффекты — как гремлины, ломают все доступные программисту инструменты, до которых доберутся: типизация, тесты, интерактивные среды, статические анализаторы в IDE, код-ревью.</p>

<p>Но почему это всё действительно важно? Ну да, что-то стало сложнее сделать, но программисты привыкли к борьбе со сложностями. И в отдельных пунктах я приводил результаты такой борьбы — инструменты, которые призваны хоть как-то уменьшить негативное влияние сайд-эффектов.</p>

<p>Проблема в том, что сайд-эффекты не только усложняют написание и работу с самим кодом, но и «ломают» два <em>базовых</em> способа разработки ПО. И это уже реальная проблема.</p>

<h2 id="два-сломанных-способа-разработки-по">Два <del>сломанных</del> способа разработки ПО</h2>

<p>На самом <em>высоком</em> уровне, по большому счету, существует только <a href="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design">два способа разработки</a>. Всё остальное — либо их комбинации, либо производные.</p>

<p><img src="/images/side-effects/vityaz.png" alt="Top Down or Bottom up" /></p>

<p>Давайте рассмотрим на простом примере оба способа. Предположим, что нам надо разработать систему <code class="highlighter-rouge">printSum</code>, которая будет выводить на экран сумму какого-то списка.</p>

<h4 id="сверху-вниз-aka-нисходящий-стиль-aka-top-down">«Сверху-вниз» a.k.a Нисходящий стиль a.k.a Top-Down</h4>

<p>Определяем спецификацию самого верхнего уровня API — описываем входное и выходное воздействие:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">printSum</span><span class="p">(</span><span class="nx">list</span><span class="p">:</span> <span class="nb">Array</span><span class="p">):</span> <span class="nx">PrintedSumToScreenEffect</span>
</code></pre></div></div>
<p>Затем определяем спецификации API уровнем ниже, которые необходимы, чтобы из <code class="highlighter-rouge">Array</code> получить <code class="highlighter-rouge">PrintedSumToScreenEffect</code>. Очевидно, что нам требуются две функции:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sum</span><span class="p">(</span><span class="nx">list</span><span class="p">:</span> <span class="nb">Array</span><span class="p">):</span> <span class="nx">number</span>
<span class="nx">printToScreen</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">number</span><span class="p">):</span> <span class="nx">PrintedSumToScreenEffect</span>
</code></pre></div></div>

<p>Теперь, просто глядя на спецификации, мы понимаем, что сначала необходимо вызывать от <code class="highlighter-rouge">list</code> функцию <code class="highlighter-rouge">sum</code>, а затем от её результата —  <code class="highlighter-rouge">printToScreen</code>.</p>

<p>Осталось придумать, как записывать спецификацию для описания входных и выходных данных:</p>

<ul>
  <li>В идеале она должна описывать все возможные входные воздействия и результаты довольно общим образом — тесты подходят не очень хорошо, так как они описывают отдельные кейсы вместо общего поведения системы.</li>
  <li>Мы должны иметь возможность проверить, что разработанная нами программа соответствует изначальной спецификации, иначе при имплементации есть большой шанс получить значительное расхождение со спецификацией. Диаграммы и прочие способы, связанные с <a href="https://ru.wikipedia.org/wiki/UML">ИЗО</a>, не дадут нам такой возможности.</li>
</ul>

<p>Вы, наверно, уже догадались, что лучше всего здесь <a href="http://blog.ploeh.dk/2015/08/10/type-driven-development/">подойдёт хорошая система типов</a>.</p>

<blockquote>
  <p>Люди иногда спрашивают: «Что служит аналогом UML для Haskell?». Когда меня впервые спросили об этом 10 лет назад, я подумал: «Ума не приложу. Может быть, нам стоит придумать свой UML». Сейчас я думаю: «Это просто типы!». Люди рисуют UML-диаграммы, чтобы понять общую схему программы. Именно этим занимаются программисты на функциональных языках и на Haskell, когда придумывают сигнатуры типов для модулей и функций в этих модулях.</p>

  <p>– <cite><a href="http://fprog.ru/2010/issue6/interview-simon-peyton-jones/">Саймон Пейтон Джонс</a></cite></p>
</blockquote>

<p>Однако, как мы выяснили, без определённых уловок большая часть систем типов не способны работать с сайд-эффектами и уж точно не могут вывести типы таких эффектов из контекста. Можно было бы, конечно, заменить типы тестами (что, например, сделано во всем известном Test Driven Development), но, как мы уже увидели, тесты не очень хорошо подходят для этого из-за своей дискретной природы, к тому же они тоже страдают от сайд-эффектов.</p>

<p>Таким образом сайд-эффекты ломают первый базовый способ разработки ПО. Но, может, со вторым нам повезёт больше?</p>

<h4 id="снизу-вверх-aka-восходящий-стиль-aka-bottom-up">«Снизу-вверх» a.k.a Восходящий стиль a.k.a Bottom-Up</h4>

<p>Мы можем пойти с другой стороны.</p>

<p>Уже по описанию задачи видно, что нам надо будет уметь выводить что-то на экран и надо уметь складывать. Мы не будем пытаться определить точные спецификации. Вместо этого просто напишем общие и минимально необходимые функции для этого. Больше всего эти функции будут похожи на отдельные небольшие библиотеки (очень малоспецифичные и очень переиспользуемые единицы), так как мы ещё не знаем, что за API нам придётся с их помощью строить.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// -&gt; 10</span>
<span class="nx">print</span><span class="p">(</span><span class="s1">'Hello'</span><span class="p">,</span> <span class="nx">screen</span><span class="p">)</span>
<span class="c1">// -&gt; prints 'Hello' to screen</span>
</code></pre></div></div>

<p>Затем строим из этих функций API более высокого уровня:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printSum</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span>
  <span class="nx">print</span><span class="p">(</span><span class="nx">sum</span><span class="p">(...</span><span class="nx">list</span><span class="p">),</span> <span class="nx">screen</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Для такого итеративного процесса нам необходим инструмент, позволяющий легко экспериментировать с небольшими кусочками кода и иметь возможность быстро запустить отдельные функции на разных входных данных. При этом в процессе разработки нам не так важно зафиксировать некоторый результат и уметь его воспроизводить — вероятней всего, мы редко будем менять имплементацию уже написанного API. Тесты тут будут скорее мешать низкой скоростью ответной реакции и своей хрупкостью.</p>

<p>Лучше всего для такого стиля разработки подойдёт <code class="highlighter-rouge">REPL</code>. Собственно, такой вид разработки и получил распространие в языках с богатой практикой использования <code class="highlighter-rouge">REPL</code>: <code class="highlighter-rouge">Lisp</code>, <code class="highlighter-rouge">SmallTalk</code>.</p>

<p>Однако, как мы помним, <code class="highlighter-rouge">REPL</code> теряет свое главное преимущество (быстрый отклик) при разработке кода с сайд-эффектами. Второй фундаментальный способ тоже не выдержал этой битвы.</p>

<p><img src="/images/side-effects/vityaz-no-way.png" alt="Dead knigth" /></p>

<p>Но ведь не весь наш код содержит сайд-эффекты? И, может, все эти неприятности касаются только тех участков, в которых мы их используем? Может, просто стараться использовать поменьше «грязных» функций и побольше «чистых»?</p>

<h2 id="лед-9-для-программного-кода">Лед-9 для программного кода</h2>

<p><img src="/images/side-effects/cats-cradle.jpg" alt="Cats cradle" /></p>

<blockquote>
  <p>- Ты читал «Колыбель для кошки»?</p>

  <p>- Нет.</p>

  <p>- Итак, в этом романе мир погибает потому, что во льду обнаружена молекула, которая при соприкосновении с водой превращает её в лед. А поскольку все воды мира связаны — пруд с ручьем, ручей с рекой, река с озером, озеро с океаном — таким образом, весь мир замерзает и погибает. И эта молекула называется «Лед-9».</p>

</blockquote>

<p>Программисты, заставшие <code class="highlighter-rouge">JS</code> без <code class="highlighter-rouge">Promise</code> и <code class="highlighter-rouge">async-await</code>, могут почувствовать что-то знакомое в описании недостатков сайд-эффектов. Эти же проблемы зачастую упоминались в обсуждении асинхронных функций, основанных на коллбэках.</p>

<blockquote>
  <p>Асинхронность и сайд-эффекты выглядят довольно связанными проблемами — решив только одну из них, вы не избавитесь от всех их недостатков, они лишь переместятся. С другой стороны, хорошее решение одной из этих проблем может помочь решить другую. В дальнейшем мы увидим, что это не случайно и на самом деле оба этих явления представляют собой лишь частные случаи более фундаментальной проблемы отсутствия общего способа абстракции control-flow программы и выражения его first-class значениями.</p>
</blockquote>

<p>Но самое ужасное в таких функциях было то, что они заражали весь код, в котором использовались. Обычная функция при использовании в ней функции с коллбэком переставала возвращать результат через <code class="highlighter-rouge">return</code> и начинала прокидывать его в коллбэк — и, в свою очередь, сама становилась «ядом» для использующего её кода.</p>

<p>Появилась даже метафора двухцветного языка:</p>

<ul>
  <li><a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">Статья Bob Nystrom</a></li>
  <li><a href="https://www.youtube.com/watch?v=OGSppLmGchY">Доклад Андрея Саломатина</a></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">blue</span><span class="err">•</span><span class="kd">function</span> <span class="nx">doSomethingAzure</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// This is a blue function...</span>
<span class="p">}</span>
<span class="nx">red</span><span class="err">•</span><span class="kd">function</span> <span class="nx">doSomethingCarnelian</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// This is a red function...</span>
<span class="p">}</span>

<span class="nx">blue</span><span class="err">•</span><span class="kd">function</span> <span class="nx">doSomethingAzure</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doSomethingCarnelian</span><span class="p">()</span><span class="err">•</span><span class="nx">red</span><span class="p">;</span>  <span class="c1">// Error — you can't call red inside blue</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Все функции в языке делятся на «красные» и «синие». И чтобы вызвать «красную» функцию в «синей», нам необходимо перекрасить «синюю» функцию в красный цвет.</p>

<p>Происходило это из-за того, что подобные асинхронные функции для взаимодействия с кодом не использовали стандартные способы взаимодействия — возврат значения через <code class="highlighter-rouge">return</code>. Как мы помним, функции с сайд-эффектами ведут себя так же и возвращают свои результаты неявно.</p>

<p>Поэтому всё то же самое применимо и к ним:</p>

<blockquote>
  <p>Функция с сайд-эффектом внутри сама становится сайд-эффектом. Следовательно, используя такую функцию внутри другой (чистой), мы автоматически превращаем её в грязную — она начинает возвращать часть результата неявно. И так далее до самой вершины стека вызовов.</p>
</blockquote>

<p>Рассмотрим пример. Допустим, у нас есть такая иерархия вызовов:</p>

<p><img src="/images/side-effects/pure_tree.svg" alt="Pure tree" /></p>

<p>Все вызовы чистые и предсказуемые. С ними нет никаких проблем.</p>

<p>Но неожиданно нам понадобилось кэшировать результаты вычисления функции <code class="highlighter-rouge">calcForItem</code> в <code class="highlighter-rouge">localStorage</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">calcForItem</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kd">var</span> <span class="nx">cachedResult</span> <span class="o">=</span> <span class="nx">localStorage</span>
    <span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="nx">argsHash</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">cachedResult</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cachedResult</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">localStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="nx">argsHash</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И наша иерархия стала выглядеть так (красным отмечены функции с сайд-эффектами):</p>

<p><img src="/images/side-effects/not_pure_tree.svg" alt="Not pure tree" /></p>

<p>Изменив код всего <em>одной</em> функции, мы изменили свойства (в плане тестируемости, надёжности, композируемости) для <em>всего</em> стека вызовов.</p>

<p>В некотором смысле мы теряем <em>контроль</em> над своим кодом. Его поведение может измениться, хотя он сам останется прежним — просто API, на котором основан наш код, <em>внезапно</em> станет «грязным» и «заразит» его.</p>

<h2 id="in-soviet-russia-side-effects-control-you">In Soviet Russia side-effects control you!</h2>

<p>Если мы не контролируем ПО, то оно начинает контролировать нас (разработчиков). В результате всего вышесказанного у нас получается код, который:</p>

<ul>
  <li>
    <p><em>нельзя</em> полноценно протестировать, да и, чтобы протестировать хоть как-то, нужно приложить много усилий — из-за этого мы пишем недостаточно тестов. Проверьте свое покрытие кода с сайд-эффектами и кода, работающего только с данными — скорее всего, во втором случае цифра будет намного выше;</p>
  </li>
  <li>
    <p><em>нельзя</em> полноценно типизировать, потому что значительную часть фронтенд-кода занимают функции типа <code class="highlighter-rouge">handleClick(): void</code>, <code class="highlighter-rouge">dispatch(): void</code>, <code class="highlighter-rouge">setState(): void</code>;</p>
  </li>
  <li>
    <p><em>нельзя</em> верифицировать или попробовать доказать его свойства при помощи property-based тестов — у большей его части просто нет каких-либо предсказуемых свойств;</p>
  </li>
  <li>
    <p>неудобен для работы в интерактивной среде (<code class="highlighter-rouge">REPL</code>), потому что там не получится работать с DOM-элементами или безопасно послать HTTP-запрос;</p>
  </li>
  <li>
    <p>практически не поддается рефакторингу, так как сайд-эффекты создают неявные зависимости;</p>
  </li>
  <li>
    <p>непредсказуем — невозможно создать надёжные инструменты воспроизведения поведения приложения. Обычно не является проблемой по результатам мониторинга понять, <em>что</em> произошо. Но вот <em>почему</em> так произошло — может быть совершенно неясно, так как части приложения влияют друг на друга неявно;</p>
  </li>
  <li>
    <p>очень тяжело переиспользуется. Иногда без внесения правок в исходники нельзя переиспользовать то или иное решение. Поэтому наученные горьким опытом разработчики зачастую стремятся не переиспользовать крупные части своего приложения (не говоря уже о больших и сложных сторонних компонентах), так как не ясно, возможно ли будет избавиться от некоторых нежелательных действий, если они вдруг станут не нужны.</p>
  </li>
</ul>

<p>При этом разработчики сами по себе не хотят писать такой код. Почти любой разработчик скажет, что код должен быть хорошо тестируемым, переиспользуемым и так далее. Нас учат этому с самого начала работы в индустрии.</p>

<p>Однако сайд-эффекты в нашем коде вынуждают нас частично отказаться от всех хороших практик и практически всех доступных программисту инструментов.</p>

<p>Софт, который контролирует людей? Я знаю, кому это точно понравится:</p>

<p><img src="/images/side-effects/skynet.png" alt="Skynet" /></p>

<p>При этом мы не пытаемся избавиться от этого контроля и воспринимаем его как что-то само собой разумеющееся. Все эти проблемы давно известны, но мы не пытаемся воздействовать на их <em>причину</em>, а только исправляем отдельные симптомы:</p>

<ul>
  <li><code class="highlighter-rouge">React</code> стал популярен во многом благодаря тому, что абстрагировал часть сайд-эффектов, возникающих при работе с <code class="highlighter-rouge">DOM</code>. Но только часть — <a href="https://facebook.github.io/react/docs/handling-events.html">работа с событиями</a> и <a href="https://facebook.github.io/react/docs/refs-and-the-dom.html">работа с отдельными элементами</a> всё так же происходят при помощи сайд-эффектов.</li>
  <li><code class="highlighter-rouge">Redux</code> позволил описывать преобразования глобального мутабельного стейта при помощи <a href="http://redux.js.org/docs/basics/Reducers.html">чистых функций</a>. Однако сами изменения вызываются при помощи грязной функции <a href="http://redux.js.org/docs/api/Store.html#dispatch"><code class="highlighter-rouge">dispatch</code></a>. Да и, к примеру, то же самое сетевое взаимодействие всё так же продолжает порождать сайд-эффекты (хотя это можно исправить при помощи <a href="https://github.com/redux-loop/redux-loop"><code class="highlighter-rouge">redux-loop</code></a>, <a href="https://github.com/yelouafi/redux-saga"><code class="highlighter-rouge">redux-saga</code></a>).</li>
  <li><code class="highlighter-rouge">Angular 2</code>, напротив, позволяет обрабатывать <a href="http://learnangular2.com/outputs/">события без использования коллбэков (то есть без сайд-эффектов)</a>. Но он не имеет какого-либо решения для абстракции остальных сайд-эффектов.</li>
</ul>

<h2 id="i-have-a-dream">I have a dream…</h2>

<p>Попытки решать фундаментальную проблему, борясь только с её отдельными проявлениями, вряд ли могут увенчаться успехом.</p>

<blockquote>
  <p>Нам необходимо фундаментальное решение проблемы сайд-эффектов в нашем коде. Причём оно должно было максимально общим — не привязанным к какому-то фреймворку или инфраструктуре и не навязывающим какую-либо конкретную архитектуру. Оно должно решать ровно одну проблему и делать это хорошо.</p>

</blockquote>

<p>Но как мы можем создать такое решение?</p>

<p>Мы не можем избавиться от сайд-эффектов совсем или даже уменьшить их число — нельзя вдруг начать делать меньше <code class="highlighter-rouge">HTTP</code> запросов или меньше работать с <code class="highlighter-rouge">DOM</code>. Сайд-эффекты — взаимодействие с внешним миром — это вообще самая главная часть нашего приложения. Если приложение не делает их, значит, скорее всего, оно вообще ничего не делает.</p>

<p><img src="/images/side-effects/haskell.png" alt="No side effects" /></p>

<p>Но мы можем <em>полностью</em> отделить логику нашего приложения от сайд-эффектов.</p>

<p>Всё наше приложение станет полностью чистой функцией — будет явно принимать все входящие воздействия и явно возвращать выходные. А сайд-эффекты будут исполняться отдельно от основного приложения.</p>

<p>Существует минимум 3 способа сделать это, и все они основаны на теоретических основах Computer Science, разработанных около 40 лет назад.</p>

<p>Все эти способы объединяет то, что они созданы для абстракции <code class="highlighter-rouge">control-flow</code> программы. <code class="highlighter-rouge">Control-flow</code> — это скелет нашей программы, её базис, поэтому эти способы возникают при решении большей части проблем в Computer Science — не только при решении проблемы сайд-эффектов. Однако это тема для следующей статьи.</p>

</article>






<div id="disqus_thread"></div>
<script type="text/javascript">
	var disqus_shortname = 'blogcsssrru';

	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

			</div>
		</div>
	</div>


	<script type="text/javascript">
	(function (d, w, c) {
		(w[c] = w[c] || []).push(function() {
			try {
				w.yaCounter25896539 = new Ya.Metrika({id:25896539,
						webvisor:true,
						clickmap:true,
						trackLinks:true,
						accurateTrackBounce:true});
			} catch(e) { }
		});

		var n = d.getElementsByTagName("script")[0],
			s = d.createElement("script"),
			f = function () { n.parentNode.insertBefore(s, n); };
		s.type = "text/javascript";
		s.async = true;
		s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

		if (w.opera == "[object Opera]") {
			d.addEventListener("DOMContentLoaded", f, false);
		} else { f(); }
	})(document, window, "yandex_metrika_callbacks");
	</script>
	<noscript><div><img src="//mc.yandex.ru/watch/25896539" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

</body>
</html>
